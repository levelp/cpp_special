<!-- doc.py -->
Типы данных
===========
[01_types/main.cpp](01_types/main.cpp)

Ссылки и указатели
==================
``` cpp
void inc2(int& value) {
  value += 2;
}

int main() {
  int value = 11;
  // int & - объявляем ссылку
  int& b = value; // b и value - одна и та же переменная
  // только с 2-мя именами
  b = 10; // изменилось value
  value = 12; // изменилось b

  int* ptrA, valueA; // ptrA - указатель, valueA - значение
  valueA = 122;

  ptrA = &value; // Указатель ptrA указывает на
  // переменную value

  // *ptrA и value - одна и та же переменная
  value = 1000; // изменится и *ptrA
  *ptrA = 111; // изменится и value

  int d;
  ptrA = &d;

  int x = 1, y = 10;
  inc2(x);
  inc2(y);

  return 0;
}
```

[02_refs/main.cpp](02_refs/main.cpp)

Разложение числа на слагаемые
=============================
Число для разложение на слагаемые:
``` cpp
int N = 10;
```

Слагаемые будем хранить в массиве A:
``` cpp
int A[100];
```

Алгоритм: будем добавлять очередное слагаемое и вызывать рекурсивно разложение оставшейся суммы
* 10 = 10
* 10 =  9 + ...
* 10 =  8 + ...
...
* 10 =  1 + ...

Рекурсивная функция:
``` cpp
// sum - сумма для разложения
// prev - верхний предел для слагаемого (предыдущее слагаемое)
// i - индекс текущего слагаемого = количество предыдущих слагаемых
void f(int sum, int prev, int i) {
  // Перебираем x - значение текушего слагаемого
  for(int x = min(sum, prev); x >= 1; --x) {
    A[i] = x; // Сохраняем слагаемое в массив (для печати)
    // Если оставш. сумма равна x, то разложение получено => печатаем его
    if(sum == x) {
      // Печатаем сумму
      cout << N << " = " << A[0];
      for(int j = 1; j <= i; ++j)
        cout << " + " << A[j];
      cout << endl;
    } else // Продолжаем раскладывать
      f(sum - x, x, i + 1);
  }
}
```

Вызов из основной программы:
``` cpp
  f(N, N, 0);
```

[04_sums/main.cpp](04_sums/main.cpp)

Напечатать все правильные скобочные последовательности
------------------------------------------------------
Скобочные последовательности надо вывести в лексикографическом порядке
Строка со скобками
``` cpp
char s[100] = {0};
```

Количество пар скобок
``` cpp
int N = 4;
```

Рекурсивная расстановка скобок:
``` cpp
// open - количество поставленных открывающих скобок
// close - количество поставленных закрывающих скобок
void f(int open, int close) {
  // Все скобки уже поставлены
  if(open == N && close == N) {
    cout << s << endl;
    return;
  }
  int p = open + close; // Текущая позиция
  // Ставим открывающую скобку
  if(open < N) {
    s[p] = '(';
    f(open + 1, close);
  }
  // Ставим закрывающую скобку
  if(close < open) {
    s[p] = ')';
    f(open, close + 1);
  }
}
```

Вызов функции: 0 открывающих и 0 закрывающих
``` cpp
  f(0, 0);
```

[05_brackets/main.cpp](05_brackets/main.cpp)

Задание: сумма элементов массива
--------------------------------
Нумерация элементов массива с 0
Все элементы на чётных местах взять с "+"
Все элементы на нечётных местах с "-"
Чётные: 0, 2, 4, 6 и т.д.
Нечётные: 1, 3, 5...
[homework/main.cpp](homework/main.cpp)

