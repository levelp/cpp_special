/// Указатели + динамические массивы
/// ================================
#include <iostream>
#include <math.h> // По стандарту C - библиотеки на .H
#include <cmath> // По стандарту C++ 11: без расширения
// #include<NAME.h>
// #include<cNAME>
#include <cstring> // Функция memcpy

#define SHOW(x) cout << #x << " = " << x << endl;

using namespace std;

// Типы данных для разбора:
// DWORD

/// Передача одномерных массивов как входных параметров
/// ---------------------------------------------------
// Передаём одномерный массив c неизвестным размером
// для вывода на экран
// Размер массива не определить по самой переменной A
// Поэтому дополнительно нужно передавать size -
// количество элементов (размер массива)
void showArray(int A[], int size) {
  for(int i = 0; i < size; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

void showArray2(int* A, int size) {
  for(int i = 0; i < size; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

// Массив с известным заранее размером
void showArray3(int A[10]) {
  for(int i = 0; i < 10; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

// Возвращаем одномерный массив как результат
// С неизвестным размером
int* array1(int A[], int size) {
  return A;
}

// Создать копию одномерного массива
int* copyArray(int A[], int size) {
  // Создаём массив в памяти для копирования
  int* aCopy = new int[size];
  // Копирование в цикле
  for(int i = 0; i < size; i++)
    aCopy[i] = A[i];
  // Копирование куска памяти:
  //  http://en.cppreference.com/w/cpp/string/byte/memcpy
  //     куда  откуда  размер
  memcpy(aCopy, A, size * sizeof(int));
  // Теперь массив aCopy можно менять независимо от A
  return aCopy;
}

/// Передача 2D массива
/// -------------------
// Вывод двухмерного массива
void showArray2D(int** A, int N, int M) {
  for(int i = 0; i < N; i++) {
    for(int j = 0; j < M; j++)
      cout << "A[" << i << "][" << j << "] = " << A[i][j] << endl;
    cout << endl;
  }
}

// ** - количество звёздочек равно количеству измерений массива
void showArray2D_2(int** A, int N, int M) {
  for(int i = 0; i < N; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

// 2D массив с заранее известным размером
void showArray2D_4x4(int A[4][4]) {
  for(int i = 0; i < 4; i++)
    for(int j = 0; j < 4; j++)
      cout << A[i][j] << endl;
}

// Возврат 2D массива как результата функции
int** incArray2D(int** A, int N, int M, int delta) {
  for(int i = 0; i < N; i++)
    for(int j = 0; j < M; j++)
      A[i][j] += delta;
  return A;
}

int x; // Переменная целого типа
int x1[] = {1, 2}; // Одномерный массив
int x2[2][2] = {{1, 2}, {3, 4}}; // Двухмерный массив
// Обязательно указывать размеры по каждому измерению

/// Вычисление размера массива
// "Hack" для вывода размера массива в той же функции
// Определение размера массива с помощью шаблонной функции
// T - тип элементов массива
// S - размер массива (он должен быть известен при компиляции)
// Работает только если компилятор может определить размер
// на этапе компиляции
template <typename T, unsigned S>
inline unsigned arraySize(const T (&v)[S]) {
  return S;
}

/// Изменение размеров строки
/// src - исходная строка
/// len - длина строки (не думаем про символ 0 в конце строки)
/// addLen - насколько изменяем длину строки
/// +1 - на один символ увеличиваем
/// -3 - на три символа уменьшаем и т.д.
char* resize(char* src, int& len, int addLen) {
  // Вычисляем новую длину строки
  int newLen = len + addLen;
  // Строка-результат
  // Заводим массив char нужного размера в динамической памяти
  char* res = new char[newLen];
  // Копируем из старого массива src в новый массив res
  // Если массив уменьшается, то надо скопировать только newLen символов
  // Например, если строка была 8 символов, а новая длина 4,
  // то нужно скопировать только 4 символа.
  // Если массив увеличивается, то надо скопировать len символов исходной строки
  memcpy(res, src, min(newLen, len));
  // XXXXXXX
  // XXXXXXX000000
  // <-len->
  // Если новая строчка длинее, то зануляем остаток строки
  // Отступаем от начала новой строки len символов
  if(newLen > len)
    memset(res + len, 0, newLen - len);
  // Записываем новую длину строки
  len = newLen;
  // Освобождаем память со старой строкой
  delete[] src;
  // Возвращаем результат
  return res;
}

int main() {
  /// ПРИМЕР:
  /// Использование массивов и указателей
  /// В ОДНОМ коде (в ОДНОЙ функции)

  // Массив, сразу заполненный числами
  int M[5] = {2, 5, 10, 4, 3};
  // Далее будем выводить третий элемент (10)
  // (у него индекс 2)
  SHOW(M[2]);
  SHOW(2[M]); // или так
  SHOW(M); // Печатаем указатель

  //      ----------------------
  // M -->| 2 | 5 | 10 | 4 | 3 |
  //      ----------------------
  // M - хранит адрес первого элемента
  SHOW((int)M); // Адрес в памяти
  SHOW((int)(M + 1));
  SHOW((int)(M + 2));
  SHOW((int)(M + 3));
  int* uk = M + 10; //

  int* M2 = M; // M2 - новая переменная - указатель
  // Тип этой переменной int* - указатель на int
  // M2 - указывает на первый элемент массива M
  SHOW(M2);

  // Вывожу первый элемент массива на экран
  SHOW(*M2);
  SHOW(M2[0]);
  // Выводим элемент с индексом 2 (т.е. число 10)
  SHOW(*(M2 + 2));
  SHOW(M2[2]);
  // Запись в обратном порядке даёт тот же результат
  SHOW(*(2 + M2));
  SHOW(2[M2]);  // 2[M2] = *(2+M2) = *(M2+2) = M2[2]

  int* M3 = M; // Сохраняю указатель в M3
  M3 = 0; // "теряю" указатель M3
  M3 = M; // "восстанавливаю" указатель M3

  // Печатаю все элементы массива M с помощью индекса
  int i;
  for(i = 0; i < 5; i++)
    cout << "M[" << i << "] = " << M[i] << endl;
  // i = 5
  SHOW(i);

  // Двигаем указатель в цикле
  for(int* MP = M; MP < M + 5; MP++) { // MP существует в стеке только на время работы цикла
    SHOW(MP[0]);
    SHOW(*MP);
  }

  // Вызываем функцию вывода массива
  showArray(M, 5);

  /// Создаём в динамической памяти 2D массив X
  //int** X2 = new int[5][5]; // Так нельзя!
  int** X = new int* [5]; // Указатель указателей
  for(int i = 0; i < 5; i++) // Инициализируем каждую строчку массива
    X[i] = new int[5];
  // Инициализируем 0-ой элемент 0-ой строчки
  X[0][0] = 10;
  // Копируем массив M в элемент с индексом 3
  delete[] X[3];
  X[3] = copyArray(M, 5);

  // int* dynArray - сам указатель находится в стеке
  // А результат операции new - в динамической памяти
  int* dynArray; // = new int[20];
  dynArray = copyArray(M, 5);
  delete[] dynArray;

  // Удаляем из динамической памяти 2D массив
  for(int i = 0; i < 5; i++) // Удаляем каждую строчку массива
    delete[] X[i];
  delete[] X; // Удаляем весь массив массивов

  /// Заполнить весь массив значениями 0
  int zeros[10] = {0};
  SHOW(arraySize(zeros));
  /// Заполнить динамический массив значениями 0
  int* zerosDyn = new int[1000];
  // ... поработали с массивом ...
  /// Обнуляем массив
  int valueToFill = 0; // Каким значением заполнить
  // http://en.cppreference.com/w/cpp/string/byte/memset
  // http://ru.cppreference.com/w/cpp/string/byte/memset
  memset(zerosDyn, valueToFill, sizeof(int) * 1000);

  /// Увеличение размера массива
  /// --------------------------
  // Заводим массив oldA
  // oldA - указатель на char, который сейчас находится в стеке
  // Выполняя new char[size] мы выделяем новый кусок динамической памяти
  // и записываем указатель на неё в oldA
  int size = 9;
  char* oldA = new char[size];
  // Копируем в динамическую память строчку с конкретными данными
  strcpy(oldA, "ABCDEFGH");
  // Можем заполнять по одному элементу
  oldA[0] = 'A';
  oldA[1] = 'B'; // ...
  // Меняем указатель, теперь он указывает на константу
  // oldA = "ABCDEFGH";

  // Без создания нового массива размер не увеличить
  // Ходим добавить одну букву (один элемент) в новый массив
  // 1. Выделяем новый кусок динамической памяти
  char* newA = new char[size + 1];
  // 2. Копируем содержимое старого массива в новый
  memcpy(newA, oldA, size);
  // 3. Добавляем новый символ в конец строки
  //int len = 8; // strlen(oldA);
  // До добавления size = 9
  // | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8  |
  // | A | B | C | D | E | F | G | H | \0 |
  // После добавления:
  // | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9  |
  // | A | B | C | D | E | F | G | H | I | \0 |
  newA[8] = 'I';
  newA[9] = 0; // Нулевой символ в конце строки
  // Увеличиваем записанный размер
  // Потому что размер newA на 1 больше чем размер oldA
  size++;
  // Нужно помещать 0 в конец строки чтобы правильно работал printf()
  // cout "понимает" char* и выводит его как строчку
  SHOW(oldA);
  SHOW(newA);
  delete[] oldA;

  // Ставим последний символ на место первого
  // size - 2
  newA[0] = newA[size - 2];
  SHOW(newA);

  // Когда уменьшаем массив - принцип тот же

  /// Уменьшаем размер строки до 2-х символов используя нашу функцию
  newA = resize(newA, size, 2 - size);
  cout << newA << endl;

  return 0;
}
