/// Указатели + динамические массивы
/// ================================
#include <iostream>
#include <math.h> // По стандарту C - библиотеки на .H
#include <cmath> // По стандарту C++ 11: без расширения
// #include<NAME.h>
// #include<cNAME>
#include <cstring> // Функция memcpy

#define SHOW(x) cout << #x << " = " << x << endl;

using namespace std;

// Типы данных для разбора:
// DWORD

/// Передача одномерных массивов как входных параметров
/// ---------------------------------------------------
// Передаём одномерный массив c неизвестным размером
// для вывода на экран
// Размер массива не определить по самой переменной A
// Поэтому дополнительно нужно передавать size -
// количество элементов (размер массива)
void showArray(int A[], int size) {
  for(int i = 0; i < size; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

void showArray2(int* A, int size) {
  for(int i = 0; i < size; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

// Массив с известным заранее размером
void showArray3(int A[10]) {
  for(int i = 0; i < 10; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

// Возвращаем одномерный массив как результат
// С неизвестным размером
int* array1(int A[], int size) {
  return A;
}

// Создать копию одномерного массива
int* copyArray(int A[], int size) {
  // Создаём массив в памяти для копирования
  int* aCopy = new int[size];
  // Копирование в цикле
  for(int i = 0; i < size; i++)
    aCopy[i] = A[i];
  // Копирование куска памяти:
  //  http://en.cppreference.com/w/cpp/string/byte/memcpy
  //     куда  откуда  размер
  memcpy(aCopy, A, size * sizeof(int));
  // Теперь массив aCopy можно менять независимо от A
  return aCopy;
}

/// Передача 2D массива
/// -------------------
// Вывод двухмерного массива
void showArray2D(int** A, int N, int M) {
  for(int i = 0; i < N; i++) {
    for(int j = 0; j < M; j++)
      cout << "A[" << i << "] = " << A[i] << endl;
    cout << endl;
  }
}

// ** - количество звёздочек равно количеству измерений массива
void showArray2D_2(int** A, int N, int M) {
  for(int i = 0; i < N; i++)
    cout << "A[" << i << "] = " << A[i] << endl;
}

// 2D массив с заранее известным размером
void showArray2D_4x4(int A[4][4]) {
  for(int i = 0; i < 4; i++)
    for(int j = 0; j < 4; j++)
      cout << A[i][j] << endl;
}

// Возврат 2D массива как результата функции
int** incArray2D(int** A, int N, int M, int delta) {
  for(int i = 0; i < N; i++)
    for(int j = 0; j < M; j++)
      A[i][j] += delta;
  return A;
}

int x; // Переменная целого типа
int x1[] = {1, 2}; // Одномерный массив
int x2[2][2] = {{1, 2}, {3, 4}}; // Двухмерный массив
// Обязательно указывать размеры по каждому измерению

/// Вычисление размера массива
// "Hack" для вывода размера массива в той же функции
// Определение размера массива с помощью шаблонной функции
// T - тип элементов массива
// S - размер массива (он должен быть известен при компиляции)
// Работает только если компилятор может определить размер
// на этапе компиляции
template <typename T, unsigned S>
inline unsigned arraySize(const T (&v)[S]) {
  return S;
}

int main() {
  /// ПРИМЕР:
  /// Использование массивов и указателей
  /// В ОДНОМ коде (в ОДНОЙ функции)

  // Массив, сразу заполненный числами
  int M[5] = {2, 5, 10, 4, 3};
  // Далее будем выводить третий элемент (10)
  // (у него индекс 2)
  SHOW(M[2]);
  SHOW(2[M]); // или так
  SHOW(M); // Печатаем указатель

  //      ----------------------
  // M -->| 2 | 5 | 10 | 4 | 3 |
  //      ----------------------
  // M - хранит адрес первого элемента
  SHOW((int)M); // Адрес в памяти
  SHOW((int)(M + 1));
  SHOW((int)(M + 2));
  SHOW((int)(M + 3));
  int* uk = M + 10; //

  int* M2 = M; // M2 - новая переменная - указатель
  // Тип этой переменной int* - указатель на int
  // M2 - указывает на первый элемент массива M
  SHOW(M2);

  // Вывожу первый элемент массива на экран
  SHOW(*M2);
  SHOW(M2[0]);
  // Выводим элемент с индексом 2 (т.е. число 10)
  SHOW(*(M2 + 2));
  SHOW(M2[2]);
  // Запись в обратном порядке даёт тот же результат
  SHOW(*(2 + M2));
  SHOW(2[M2]);  // 2[M2] = *(2+M2) = *(M2+2) = M2[2]

  int* M3 = M; // Сохраняю указатель в M3
  M3 = 0; // "теряю" указатель M3
  M3 = M; // "восстанавливаю" указатель M3

  // Печатаю все элементы массива M с помощью индекса
  int i;
  for(i = 0; i < 5; i++)
    cout << "M[" << i << "] = " << M[i] << endl;
  // i = 5
  SHOW(i);

  // Двигаем указатель в цикле
  for(int* MP = M; MP < M + 5; MP++) { // MP существует в стеке только на время работы цикла
    SHOW(MP[0]);
    SHOW(*MP);
  }

  // Вызываем функцию вывода массива
  showArray(M, 5);

  /// Создаём в динамической памяти 2D массив X
  //int** X2 = new int[5][5]; // Так нельзя!
  int** X = new int* [5]; // Указатель указателей
  for(int i = 0; i < 5; i++) // Инициализируем каждую строчку массива
    X[i] = new int[5];
  // Инициализируем 0-ой элемент 0-ой строчки
  X[0][0] = 10;
  // Копируем массив M в элемент с индексом 3
  X[3] = copyArray(M, 5);

  /// Заполнить весь массив значениями 0
  int zeros[10] = {0};
  SHOW(arraySize(zeros));
  /// Заполнить динамический массив значениями 0
  int* zerosDyn = new int[1000];
  // ... поработали с массивом ...
  /// Обнуляем массив
  int valueToFill = 0; // Каким значением заполнить
  // http://en.cppreference.com/w/cpp/string/byte/memset
  // http://ru.cppreference.com/w/cpp/string/byte/memset
  memset(zerosDyn, valueToFill, sizeof(int) * 1000);

  return 0;
}
