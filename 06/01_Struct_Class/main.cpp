/// Структуры и Классы
/// ==================
//
// В современном C++ единственное отличие
// класса от структуры в модификаторе доступа по-умолчанию:
// class - private
// struct - public
// Внутри класса есть Поля и Методы.
// * Поле (как бы "переменная" внутри класса), поле хранит значение.
// * Метод (как бы "функция" внутри класса).
//   - может быть сразу заголовок и реализация внутри класса
//   - может быть реализация потом, далее в коде, с указанием к какому классу она относится
// Модификатор доступа определяет из каких мест программы
// есть доступ к полю или методу класса.
// Модификаторы в порядке увеличения доступа:
// * private - доступ только изнутри этого класса
// * protected - внутри этого класса и его наследников
// * public - доступ из всех мест, где видна переменная - обьект-класса:
// из этого класса, из наследников, из других классов,
// из любого места программы, где объявлен этот класс.
//
// * static - принадлежит классу, а не конкретному объекту (конкретному экземпляру класса).

#include <iostream>

using namespace std;

// Объявление классов
// class ИмяКласса {
//   описание класса: Поля и Методы
// }
// Внешняя реализация:
// Метод:
// ТипВозвращаемогоЗначения ИмяКласса::имяМетода(параметры) {
//    Реализация метода (операторы... )
// }
// Переменных (только статических):

// Объявление Класса
class Human {
  int id;  // Идентификатор конкретного человека
 public:
  static int count; // Общее поле для всех Human
  // Конструктор
  Human() {
    count++; // Общее поле для всех Human
    id = count; // Присваиваю идентификатор конкретному человеку
    cout << "Human Constructor #" << id << endl;
  }
};

int Human::count = 0;

void f1() {
  cout << "f1 >>>" << endl;
  Human h1;
}

void f2() {
  cout << "f2 >>>" << endl;
  Human h2, h3;
}

void f3() {
  cout << "f3 >>>" << endl;
  Human h[5];
}

// Объявляем класс с одной переменной int
class Test {
  int a1;
};

// Класс с одной переменной и одной функцией описанной внутри
// Описание метода внутри класса
class Test2 {
  int a;
  // Метод - функция
  void func2() {
    // Внутри функции можно использовать переменные (поля)
    a = 10;
  }
};

// Класс с одной переменной и одной функцией описанной внутри
// Описание метода вне класса
class Test3 {
  int a;
  // Объявлем заголовок метода - функция
  void func2(int x);
};

// Реализация метода вне класса - функция
void Test3::func2(int x) {
  // Внутри функции можно использовать переменные (поля)
  a = 10;
}

// При объявлении методов названия параметров можно не указывать
// Обычно находится в .H файле
class Test4 {
  int a;
  // Объявлем заголовок метода - функция
  void func2(int, char);
};

// Реализация метода вне класса - функция
// Обычно находится в .CPP файле
void Test4::func2(int x, char c) {
  // Внутри функции можно использовать переменные (поля)
  a = 10;
}

// Модификаторы доступа
class Shape {
  // По-умолчанию private
  int privateField = 1;
 protected:
  int protectedField = 5;
 public:
  int publicField = 10;
  // Массивы
  int myArray[100];
  int* arrayPtr;
  // И снова можно private
 private:
  int private1 = 1;
  string privateStr = "Test";
};

// Не возвращаем ничего, передаём по значению
// В основной программе НЕ поменятся s1
void funcShape(Shape s1) {
  // Меняем значение поля
  s1.publicField = 100;
}

// Передаём по ссылке
// В основной программе МЕНЯЕТСЯ s1
void funcShape2(Shape& s1) {
  // Меняем значение поля
  s1.publicField = 10;
  s1.myArray[0] = 13;
  s1.arrayPtr[0] = 53;
}

// Передаём по указателю
// В основной программе МЕНЯЕТСЯ s1
void funcShape3(Shape* s1) {
  // Меняем значение поля
  s1->publicField = 10;
  (*s1).publicField = 11;
  // Обращение к элементу массива
  s1->myArray[0] = 13;
  // Самая правильная и каноничная запись
  s1->arrayPtr[0] = 53;
  // Альтернативы
  (*s1).arrayPtr[0] = 53;
  *((*s1).arrayPtr) = 53;
  // Ко второму элементу
  // Смещаем указатель на 1
  *((*s1).arrayPtr + 1) = 53;
  // Создаём указатель на int
  // Записываем в ptr адрес первого элемента arrayPtr
  int* ptr = s1->arrayPtr;
  // Двигаем указатель вперёд, на следующий элемент
  ptr++;
  *ptr = 53;
  ptr++;
  *ptr = 20;
  // "Выстреливаем себе в ногу" - перезаписываем указатель

  s1 = new Shape();
}

// Наследование
// [: ОтКакихКлассовНаследуетсяКласса]
// Объявление класса Животное
class Animal {
 public:
  string name;
};

// Класс Кошка наследует класс Животное
class Cat : public Animal {
 public:
  void say() {

  }
};

// Из функции
void myFunction() {
  Animal a;
  a.name = "Name";
}

// get/set
// Свойство (property)
// Delphi: write / read
class AnimalGetSet {
  string name;
 public:
  void setName(string name) {
    this->name = name;
  }
  string getName() {
    return "[" + name + "]";
  }
};

int main() {
  // Вызываем все 3 функции
  f1();
  f2();
  f3();
  cout << "Human.count = " << Human::count << endl;

  Animal a;
  cout << a.name << endl;
  a.name = "Новое имя";
  return 0;
}
